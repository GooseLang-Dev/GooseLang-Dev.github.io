"use strict";(self.webpackChunkgooselang_docs=self.webpackChunkgooselang_docs||[]).push([[1312],{7615:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"data-structure/task-data","title":"Task Data","description":"\ud83d\udcd8 Overview","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/data-structure/task-data.md","sourceDirName":"data-structure","slug":"/data-structure/task-data","permalink":"/dev/data-structure/task-data","draft":false,"unlisted":false,"editUrl":"https://github.com/GooseLang-Dev/gooselang.github.io/tree/main/i18n/en/docusaurus-plugin-content-docs/current/data-structure/task-data.md","tags":[],"version":"current","lastUpdatedBy":"BruceWJ","lastUpdatedAt":1754286127000,"sidebarPosition":5,"frontMatter":{"title":"Task Data","sidebar_position":5,"id":"task-data"},"sidebar":"devSidebar","previous":{"title":"Problem Records","permalink":"/dev/data-structure/problem-records"},"next":{"title":"Input Form","permalink":"/dev/category/input-form"}}');var i=s(4848),t=s(8453);const l={title:"Task Data",sidebar_position:5,id:"task-data"},d="Task Data Structure & Model",c={},a=[{value:"\ud83d\udcd8 Overview",id:"-overview",level:2},{value:"\ud83d\udd17 Dependencies",id:"-dependencies",level:2},{value:"\ud83d\udcd0 Data Structures",id:"-data-structures",level:2},{value:"Task Document (<code>Task</code>)",id:"task-document-task",level:3},{value:"Field Explanations",id:"field-explanations",level:4},{value:"Event Document (<code>EventDoc</code>)",id:"event-document-eventdoc",level:3},{value:"Field Explanations",id:"field-explanations-1",level:4},{value:"Schedule Document (<code>Schedule</code>)",id:"schedule-document-schedule",level:3},{value:"Field Explanations",id:"field-explanations-2",level:4},{value:"Task Status Constants",id:"task-status-constants",level:3},{value:"\u2699\ufe0f Core Methods &amp; Logic",id:"\ufe0f-core-methods--logic",level:2},{value:"add",id:"add",level:3},{value:"addMany",id:"addmany",level:3},{value:"get",id:"get",level:3},{value:"count",id:"count",level:3},{value:"del",id:"del",level:3},{value:"deleteMany",id:"deletemany",level:3},{value:"getFirst",id:"getfirst",level:3},{value:"consume",id:"consume",level:3},{value:"apply",id:"apply",level:3},{value:"Consumer Class",id:"consumer-class",level:3},{value:"\ud83e\uddea Usage Patterns",id:"-usage-patterns",level:2},{value:"\ud83e\udde0 Code Review and Suggestions",id:"-code-review-and-suggestions",level:2},{value:"\ud83d\udcdd File Structure",id:"-file-structure",level:2},{value:"\ud83d\udccc Notes / Observations",id:"-notes--observations",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"task-data-structure--model",children:"Task Data Structure & Model"})}),"\n",(0,i.jsx)(n.h2,{id:"-overview",children:"\ud83d\udcd8 Overview"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Task"})," module in GooseLang provides a robust, extensible system for managing background and asynchronous operations across the platform. It acts as a general-purpose task queue and event system, supporting features such as background processing, distributed event broadcasting, and scheduled jobs. The module is essential for decoupling long-running or resource-intensive operations (e.g., judging, translation, synthesis, cleanup) from user-facing flows, enabling scalable and reliable backend workflows."]}),"\n",(0,i.jsx)(n.p,{children:"The task system is designed to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Store and manage queued tasks in MongoDB"}),"\n",(0,i.jsx)(n.li,{children:"Support prioritized, concurrent, and distributed task consumption"}),"\n",(0,i.jsx)(n.li,{children:"Enable event-driven workflows and cross-process communication"}),"\n",(0,i.jsx)(n.li,{children:"Integrate with other models (e.g., judging, translation, synthesis)"}),"\n",(0,i.jsx)(n.li,{children:"Provide a foundation for future workflow orchestration and scheduling"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-dependencies",children:"\ud83d\udd17 Dependencies"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"MongoDB"}),": All tasks and events are persisted in the ",(0,i.jsx)(n.code,{children:"task"})," and ",(0,i.jsx)(n.code,{children:"event"})," collections."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event Bus"})," (",(0,i.jsx)(n.code,{children:"bus"}),"): For process-wide and cross-process event handling."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logger"}),": For structured logging and debugging."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Context"}),": For application lifecycle hooks and event registration."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"nanoid/os"}),": For unique process and task identification."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"@gooselang/utils"}),": For utility helpers (e.g., sleep)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Other Models"}),": Integrates with judging, translation, and other async workflows."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-data-structures",children:"\ud83d\udcd0 Data Structures"}),"\n",(0,i.jsxs)(n.h3,{id:"task-document-task",children:["Task Document (",(0,i.jsx)(n.code,{children:"Task"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Represents a single unit of work to be processed asynchronously."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export interface Task {\n    _id: ObjectId;         // Unique task ID\n    type: string;          // Task type (e.g., 'judge', 'translate', 'synthesize')\n    subType?: string;      // Optional subtype for further categorization\n    priority: number;      // Task priority (higher = processed first)\n    [key: string]: any;    // Additional task-specific fields\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"field-explanations",children:"Field Explanations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"_id"}),": MongoDB ObjectId, unique for each task."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"type"}),": The main category of the task (e.g., 'judge', 'translate')."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"subType"}),": Optional subcategory for more granular task types."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"priority"}),": Determines processing order; higher values are processed first."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"[key: string]: any"}),": Arbitrary fields for task-specific payloads (e.g., record IDs, config, metadata)."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"event-document-eventdoc",children:["Event Document (",(0,i.jsx)(n.code,{children:"EventDoc"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Represents a cross-process or cross-service event for distributed workflows."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export interface EventDoc {\n    ack: string[];         // List of process IDs that have acknowledged the event\n    event: number | string;// Event name or code\n    payload: string;       // Serialized event payload (JSON)\n    expire: Date;          // Expiry timestamp for the event\n    trace?: string;        // Optional trace/debug info\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"field-explanations-1",children:"Field Explanations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ack"}),": Array of process IDs that have processed the event (for deduplication)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"event"}),": Event type or name."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"payload"}),": JSON-serialized event data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"expire"}),": When the event should be considered stale and eligible for cleanup."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"trace"}),": Optional trace/debugging information."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"schedule-document-schedule",children:["Schedule Document (",(0,i.jsx)(n.code,{children:"Schedule"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"Represents a scheduled job or delayed task."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export interface Schedule {\n    _id: ObjectId;         // Unique schedule ID\n    type: string;          // Task type\n    subType?: string;      // Optional subtype\n    executeAfter: Date;    // When the task should be executed\n    [key: string]: any;    // Additional fields\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"field-explanations-2",children:"Field Explanations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"_id"}),": MongoDB ObjectId, unique for each schedule."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"type"}),": Main category of the scheduled task."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"subType"}),": Optional subcategory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"executeAfter"}),": Timestamp after which the task should be executed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"[key: string]: any"}),": Arbitrary fields for schedule-specific payloads."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"task-status-constants",children:"Task Status Constants"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"export const TASK_STATUS = {\n    STATUS_WAITING: 0,\n    STATUS_FETCHED: 1,\n    STATUS_PROCESSING: 2, // use for both translating and synthesizing\n    STATUS_COMPLETED: 3,\n    STATUS_ERROR: 4,\n    STATUS_SYSTEM_ERROR: 5\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"\ufe0f-core-methods--logic",children:"\u2699\ufe0f Core Methods & Logic"}),"\n",(0,i.jsxs)(n.p,{children:["All methods are static on the ",(0,i.jsx)(n.code,{children:"TaskModel"})," class unless otherwise noted."]}),"\n",(0,i.jsx)(n.h3,{id:"add",children:"add"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Add a new task to the queue."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"add(task: Partial<Task> & { type: string }): Promise<ObjectId>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"task"}),": Partial task object (must include ",(0,i.jsx)(n.code,{children:"type"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," The ObjectId of the newly created task"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const taskId = await TaskModel.add({ type: 'judge', priority: 10, rid: '...' });\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Called when a new background job is needed (e.g., after a user submission)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"addmany",children:"addMany"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Add multiple tasks to the queue in bulk."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"addMany(tasks: Task[]): Promise<ObjectId[]>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tasks"}),": Array of task objects"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Array of inserted ObjectIds"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const ids = await TaskModel.addMany([{ type: 'translate', ... }, { type: 'synthesize', ... }]);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used for batch job creation (e.g., bulk translation)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"get",children:"get"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Retrieve a task by its ObjectId."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"get(_id: ObjectId): Promise<Task | null>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_id"}),": Task ObjectId"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," The matching ",(0,i.jsx)(n.code,{children:"Task"})," or ",(0,i.jsx)(n.code,{children:"null"})," if not found"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const task = await TaskModel.get(taskId);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used in admin tools, debugging, or for status checks."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"count",children:"count"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Count tasks matching a query."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"count(query: Filter<Task>): Promise<number>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"query"}),": MongoDB filter for tasks"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Number of matching tasks"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const n = await TaskModel.count({ type: 'judge', priority: { $gt: 0 } });\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used for monitoring, dashboards, and analytics."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"del",children:"del"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Delete a task by its ObjectId."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"del(_id: ObjectId): Promise<any>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_id"}),": Task ObjectId"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Result of the delete operation"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"await TaskModel.del(taskId);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used for cleanup, admin tools, or after task completion."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"deletemany",children:"deleteMany"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Delete multiple tasks matching a query."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"deleteMany(query: Filter<Task>): Promise<any>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"query"}),": MongoDB filter for tasks"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Result of the delete operation"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"await TaskModel.deleteMany({ type: 'translate', priority: { $lt: 0 } });\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used for bulk cleanup or maintenance."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"getfirst",children:"getFirst"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Atomically fetch and remove the highest-priority task matching a query (for consumers)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"getFirst(query: Filter<Task>): Promise<Task | null>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"query"}),": MongoDB filter for tasks"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," The next task to process, or ",(0,i.jsx)(n.code,{children:"null"})," if none available"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const nextTask = await TaskModel.getFirst({ type: 'judge' });\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used internally by consumers to fetch work."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"consume",children:"consume"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Start a consumer that processes tasks matching a query, with concurrency and error handling."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"consume(query: any, cb: (t: Task) => Promise<void>, destroyOnError = true, concurrency = 1): Consumer\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"query"}),": MongoDB filter for tasks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cb"}),": Async function to process each task"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"destroyOnError"}),": Whether to stop the consumer on error (default: true)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"concurrency"}),": Number of concurrent tasks to process (default: 1)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," A ",(0,i.jsx)(n.code,{children:"Consumer"})," instance"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"TaskModel.consume({ type: 'judge' }, async (task) => { /* ... */ }, true, 2);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Used to start background workers for different task types."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"apply",children:"apply"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Register event listeners and initialize event streaming for distributed task/event handling."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"apply(ctx: Context): Promise<void>\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ctx"}),": Application context"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Promise resolving when setup is complete"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"await apply(appContext);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Usage:"})," Called during application startup to set up event listeners and indexes."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"consumer-class",children:"Consumer Class"}),"\n",(0,i.jsx)(n.p,{children:"Manages the lifecycle and concurrency of a task consumer."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Methods:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"consume()"}),": Main loop for fetching and processing tasks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"destroy()"}),": Stop the consumer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"setConcurrency(n)"}),": Adjust concurrency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"setQuery(q)"}),": Change the query filter"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const consumer = new Consumer({ type: 'translate' }, async (task) => { /* ... */ });\nconsumer.setConcurrency(4);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-usage-patterns",children:"\ud83e\uddea Usage Patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Background Processing:"})," After a user action (e.g., submission), a task is enqueued via ",(0,i.jsx)(n.code,{children:"add"}),", and a background worker consumes and processes it."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Distributed Event Handling:"})," The event system enables cross-process or cross-server event propagation for scalable workflows."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prioritized/Concurrent Work:"})," Multiple consumers can process tasks in parallel, with higher-priority tasks handled first."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cleanup:"})," Event listeners ensure tasks are deleted when related resources (e.g., spaces) are removed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scheduling:"})," The ",(0,i.jsx)(n.code,{children:"Schedule"})," structure supports delayed or scheduled jobs (future extension)."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-code-review-and-suggestions",children:"\ud83e\udde0 Code Review and Suggestions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robustness:"})," The consumer pattern is resilient to database downtime and process restarts, but error handling could be further improved for edge cases (e.g., partial failures, retries)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extensibility:"})," The model is flexible for new task types, but consider stricter typing for task payloads to improve safety and analytics."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Event Handling:"})," The event system is well-integrated, but distributed event delivery depends on MongoDB replica set support; fallback logic is present for single-node setups."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Indexing:"})," Indexes are created for efficient task/event queries, but should be reviewed as new workflows are added."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Observability:"})," Logging is present, but more granular metrics (e.g., task processing times, error rates) would aid monitoring."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing:"})," The system is suitable for production, but integration and load testing are recommended for high-throughput scenarios."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-file-structure",children:"\ud83d\udcdd File Structure"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src/model/task.ts"}),": Main model logic, consumer class, and event handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src/interface.ts"}),": TypeScript interfaces for ",(0,i.jsx)(n.code,{children:"Task"}),", ",(0,i.jsx)(n.code,{children:"EventDoc"}),", ",(0,i.jsx)(n.code,{children:"Schedule"}),", and related types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"task"})," (MongoDB collection): Stores all queued tasks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"event"})," (MongoDB collection): Stores cross-process events"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-notes--observations",children:"\ud83d\udccc Notes / Observations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design Choice:"})," The separation of task, event, and schedule documents enables flexible, decoupled workflows."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-Tenancy:"})," All queries can be scoped by resource (e.g., spaceId) for robust multi-tenant support."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance:"})," Prioritized and concurrent processing is supported, but tuning concurrency is important for optimal throughput."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Maintainability:"})," The codebase is modular and event-driven, but would benefit from stricter typing and more comprehensive inline documentation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Critical TODO:"})," As the system grows, consider adding retry logic, dead-letter queues, and more granular task state tracking for production robustness."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["For further details, see the source code in ",(0,i.jsx)(n.code,{children:"src/model/task.ts"})," and ",(0,i.jsx)(n.code,{children:"src/interface.ts"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);